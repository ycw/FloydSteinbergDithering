{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/gc.ts","~lib/rt.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","assembly/index.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\r\n\r\n// @ts-ignore: decorator\r\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\r\n// @ts-ignore: decorator\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n// Extra debugging\r\n\r\n// @ts-ignore: decorator\r\n@inline export const DEBUG = true;\r\n\r\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                           MM info                             │ -16\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                           GC info                             │ -12\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                          runtime id                           │ -8\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                         runtime size                          │ -4\r\n// ╞═══════════════════════════════════════════════════════════════╡\r\n// │                              ...                              │ ref\r\n@unmanaged export class BLOCK {\r\n  /** Memory manager info. */\r\n  mmInfo: usize; // WASM64 needs adaption\r\n  /** Garbage collector info. */\r\n  gcInfo: u32;\r\n  /** Runtime class id. */\r\n  rtId: u32;\r\n  /** Runtime object size. */\r\n  rtSize: u32;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\r\n// │                             count                             │\r\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\r\n// │                      Typeinfo#flags [id=0]                    │ id < count\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\r\n// │                      Typeinfo#base  [id=0]                    │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              ...                              │\r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags;\r\n  /** Base class id or `0` if none. */\r\n  base: u32;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 2,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 3,\r\n  /** Type is inherently acyclic. */\r\n  ACYCLIC = 1 << 4,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 5,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 6,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 7,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 8,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 9,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 10,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 11,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 12,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 13,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 14,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 15,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 16,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 17,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 18,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 19,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 20,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 21,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 22\r\n}\r\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\r\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\r\nimport { TypeinfoFlags } from \"shared/typeinfo\";\r\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\r\n\r\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\r\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\r\n\r\n// ╒══════════════════════ GC Info structure ══════════════════════╕\r\n// │  3                   2                   1                    │\r\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\r\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │B│color│                     refCount                          │\r\n// └─┴─────┴───────────────────────────────────────────────────────┘\r\n// B: buffered\r\n\r\n// @ts-ignore: decorator\r\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BITS = 3;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\r\n\r\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\r\n// │ Color  │ Meaning                                              │\r\n// ├────────┼──────────────────────────────────────────────────────┤\r\n// │ BLACK  │ In use or free                                       │\r\n// │ GRAY   │ Possible member of cycle                             │\r\n// │ WHITE  │ Member of garbage cycle                              │\r\n// │ PURPLE │ Possible root of cycle                               │\r\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\r\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\r\n// └────────┴──────────────────────────────────────────────────────┘\r\n// Acyclic detection has been decoupled, hence no GREEN.\r\n\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\r\n\r\n// @ts-ignore: decorator\r\n@inline const VISIT_DECREMENT = 1; // guard 0\r\n// @ts-ignore: decorator\r\n@inline const VISIT_MARKGRAY = 2;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCAN = 3;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCANBLACK = 4;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_COLLECTWHITE = 5;\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nfunction __visit(ref: usize, cookie: i32): void {\r\n  if (ref < __heap_base) return;\r\n  var s = changetype<Block>(ref - BLOCK_OVERHEAD);\r\n  switch (cookie) {\r\n    case VISIT_DECREMENT: {\r\n      decrement(s);\r\n      break;\r\n    }\r\n    case VISIT_MARKGRAY: {\r\n      if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\r\n      s.gcInfo = s.gcInfo - 1;\r\n      markGray(s);\r\n      break;\r\n    }\r\n    case VISIT_SCAN: {\r\n      scan(s);\r\n      break;\r\n    }\r\n    case VISIT_SCANBLACK: {\r\n      let info = s.gcInfo;\r\n      assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n      s.gcInfo = info + 1;\r\n      if ((info & COLOR_MASK) != COLOR_BLACK) {\r\n        scanBlack(s);\r\n      }\r\n      break;\r\n    }\r\n    case VISIT_COLLECTWHITE: {\r\n      collectWhite(s);\r\n      break;\r\n    }\r\n    default: if (DEBUG) assert(false);\r\n  }\r\n}\r\n\r\n/** Increments the reference count of the specified block by one.*/\r\nfunction increment(s: Block): void {\r\n  var info = s.gcInfo;\r\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n  s.gcInfo = info + 1;\r\n  if (isDefined(ASC_RTRACE)) onincrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n}\r\n\r\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\r\nfunction decrement(s: Block): void {\r\n  var info = s.gcInfo;\r\n  var rc = info & REFCOUNT_MASK;\r\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n  if (rc == 1) {\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\r\n    if (!(info & BUFFERED_MASK)) {\r\n      freeBlock(ROOT, s);\r\n    } else {\r\n      s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\r\n    }\r\n  } else {\r\n    if (DEBUG) assert(rc > 0);\r\n    if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\r\n      s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\r\n      if (!(info & BUFFERED_MASK)) {\r\n        appendRoot(s);\r\n      }\r\n    } else {\r\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n    }\r\n  }\r\n}\r\n\r\n/** Buffer of possible roots. */\r\n// @ts-ignore: decorator\r\n@lazy var ROOTS: usize;\r\n/** Current absolute offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var CUR: usize = 0;\r\n/** Current absolute end offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var END: usize = 0;\r\n\r\n/** Appends a block to possible roots. */\r\nfunction appendRoot(s: Block): void {\r\n  var cur = CUR;\r\n  if (cur >= END) {\r\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\r\n    cur = CUR;\r\n  }\r\n  store<Block>(cur, s);\r\n  CUR = cur + sizeof<usize>();\r\n}\r\n\r\n/** Grows the roots buffer if it ran full. */\r\nfunction growRoots(): void {\r\n  var oldRoots = ROOTS;\r\n  var oldSize = CUR - oldRoots;\r\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\r\n  var newRoots = __alloc(newSize, 0);\r\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n  memory.copy(newRoots, oldRoots, oldSize);\r\n  if (oldRoots) {\r\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n    __free(oldRoots);\r\n  }\r\n  ROOTS = newRoots;\r\n  CUR = newRoots + oldSize;\r\n  END = newRoots + newSize;\r\n}\r\n\r\n/** Collects cyclic garbage. */\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __collect(): void {\r\n\r\n  // markRoots\r\n  var roots = ROOTS;\r\n  var cur = roots;\r\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    let info = s.gcInfo;\r\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\r\n      markGray(s);\r\n      store<Block>(cur, s);\r\n      cur += sizeof<usize>();\r\n    } else {\r\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\r\n        freeBlock(ROOT, s);\r\n      } else {\r\n        s.gcInfo = info & ~BUFFERED_MASK;\r\n      }\r\n    }\r\n  }\r\n  CUR = cur;\r\n\r\n  // scanRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    scan(load<Block>(pos));\r\n  }\r\n\r\n  // collectRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\r\n    collectWhite(s);\r\n  }\r\n  CUR = roots;\r\n}\r\n\r\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\r\nfunction markGray(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\r\n  }\r\n}\r\n\r\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\r\nfunction scan(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\r\n    if ((info & REFCOUNT_MASK) > 0) {\r\n      scanBlack(s);\r\n    } else {\r\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\r\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\r\n    }\r\n  }\r\n}\r\n\r\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\r\nfunction scanBlack(s: Block): void {\r\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\r\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\r\n}\r\n\r\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\r\nfunction collectWhite(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\r\n    freeBlock(ROOT, s);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __retain(ref: usize): usize {\r\n  if (ref > __heap_base) increment(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n  return ref;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __release(ref: usize): void {\r\n  if (ref > __heap_base) decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __reset(): void {\r\n}\r\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\r\nimport { onfree, onalloc } from \"./rtrace\";\r\nimport { REFCOUNT_MASK } from \"./pure\";\r\n\r\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\r\n//                             see: http://www.gii.upv.es/tlsf/\r\n\r\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\r\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴───────╨───────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_BITS: u32 = 4;\r\n// @ts-ignore: decorator\r\n@inline const SL_SIZE: usize = 1 << <usize>SL_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\r\n// @ts-ignore: decorator\r\n@inline const SB_SIZE: usize = 1 << <usize>SB_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const FL_BITS: u32 = 31 - SB_BITS;\r\n\r\n// [00]: < 256B (SB)  [12]: < 1M\r\n// [01]: < 512B       [13]: < 2M\r\n// [02]: < 1K         [14]: < 4M\r\n// [03]: < 2K         [15]: < 8M\r\n// [04]: < 4K         [16]: < 16M\r\n// [05]: < 8K         [17]: < 32M\r\n// [06]: < 16K        [18]: < 64M\r\n// [07]: < 32K        [19]: < 128M\r\n// [08]: < 64K        [20]: < 256M\r\n// [09]: < 128K       [21]: < 512M\r\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\r\n// [11]: < 512K\r\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\r\n\r\n// Tags stored in otherwise unused alignment bits\r\n\r\n// @ts-ignore: decorator\r\n@inline const FREE: usize = 1 << 0;\r\n// @ts-ignore: decorator\r\n@inline const LEFTFREE: usize = 1 << 1;\r\n// @ts-ignore: decorator\r\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\r\n\r\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\r\n// │                          size                           │0│L│F│ ◄─┐ info\r\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\r\n// │                                                               │   │\r\n// │               ... additional runtime overhead ...             │   │\r\n// │                                                               │   │\r\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                             ...                               │   │    = 0\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: back ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\r\n// F: FREE, L: LEFTFREE\r\n@unmanaged export class Block extends BLOCK {\r\n\r\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\r\n  next: Block | null;\r\n\r\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\r\n}\r\n\r\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\r\n// `next` and `back` if free.\r\n\r\n// @ts-ignore: decorator\r\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\r\n// @ts-ignore: decorator\r\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\r\n\r\n/** Gets the left block of a block. Only valid if the left block is free. */\r\n// @ts-ignore: decorator\r\n@inline function GETFREELEFT(block: Block): Block {\r\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\r\n}\r\n\r\n/** Gets the right block of of a block by advancing to the right by its size. */\r\n// @ts-ignore: decorator\r\n@inline function GETRIGHT(block: Block): Block {\r\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\r\n}\r\n\r\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                           slMap[22]                           │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[367]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                             tail                              │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map\r\n@unmanaged class Root {\r\n  /** First level bitmap. */\r\n  flMap: usize;\r\n}\r\n\r\n// Root constants. Where stuff is stored inside of the root structure.\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_START = sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const SL_END = SL_START + (FL_BITS << alignof<u32>());\r\n// @ts-ignore: decorator\r\n@inline const HL_START = (SL_END + AL_MASK) & ~AL_MASK;\r\n// @ts-ignore: decorator\r\n@inline const HL_END = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const ROOT_SIZE = HL_END + sizeof<usize>();\r\n\r\n// @ts-ignore: decorator\r\n@lazy export var ROOT: Root;\r\n\r\n/** Gets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function GETSL(root: Root, fl: usize): u32 {\r\n  return load<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Sets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\r\n  store<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    slMap,\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Gets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\r\n  return load<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Sets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\r\n  store<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    head,\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Gets the tail block.. */\r\n// @ts-ignore: decorator\r\n@inline function GETTAIL(root: Root): Block {\r\n  return load<Block>(\r\n    changetype<usize>(root),\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Sets the tail block. */\r\n// @ts-ignore: decorator\r\n@inline function SETTAIL(root: Root, tail: Block): void {\r\n  store<Block>(\r\n    changetype<usize>(root),\r\n    tail,\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Inserts a previously used block back into the free list. */\r\nfunction insertBlock(root: Root, block: Block): void {\r\n  if (DEBUG) assert(block); // cannot be null\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n\r\n  // merge with right block if also free\r\n  if (rightInfo & FREE) {\r\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, right);\r\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\r\n      right = GETRIGHT(block);\r\n      rightInfo = right.mmInfo;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  // merge with left block if also free\r\n  if (blockInfo & LEFTFREE) {\r\n    let left = GETFREELEFT(block);\r\n    let leftInfo = left.mmInfo;\r\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\r\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, left);\r\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\r\n      block = left;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  right.mmInfo = rightInfo | LEFTFREE;\r\n  // right is no longer used now, hence rightInfo is not synced\r\n\r\n  // we now know the size of the block\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\r\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\r\n\r\n  // set 'back' to itself at the end of block\r\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // perform insertion\r\n  var head = GETHEAD(root, fl, sl);\r\n  block.prev = null;\r\n  block.next = head;\r\n  if (head) head.prev = block;\r\n  SETHEAD(root, fl, sl, block);\r\n\r\n  // update first and second level maps\r\n  root.flMap |= (1 << fl);\r\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\r\n}\r\n\r\n/** Removes a free block from internal lists. */\r\nfunction removeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // link previous and next free block\r\n  var prev = block.prev;\r\n  var next = block.next;\r\n  if (prev) prev.next = next;\r\n  if (next) next.prev = prev;\r\n\r\n  // update head if we are removing it\r\n  if (block == GETHEAD(root, fl, sl)) {\r\n    SETHEAD(root, fl, sl, next);\r\n\r\n    // clear second level map if head is empty now\r\n    if (!next) {\r\n      let slMap = GETSL(root, fl);\r\n      SETSL(root, fl, slMap &= ~(1 << sl));\r\n\r\n      // clear first level map if second level is empty now\r\n      if (!slMap) root.flMap &= ~(1 << fl);\r\n    }\r\n  }\r\n  // note: does not alter left/back because it is likely that splitting\r\n  // is performed afterwards, invalidating those changes. so, the caller\r\n  // must perform those updates.\r\n}\r\n\r\n/** Searches for a free block of at least the specified size. */\r\nfunction searchBlock(root: Root, size: usize): Block | null {\r\n  // size was already asserted by caller\r\n\r\n  // mapping_search\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    const invRound = inv - SL_BITS;\r\n    let requestSize = size < halfMaxSize\r\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\r\n      : size;\r\n    fl = inv - clz<usize>(requestSize);\r\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // search second level\r\n  var slMap = GETSL(root, fl) & (~0 << sl);\r\n  var head: Block | null = null;\r\n  if (!slMap) {\r\n    // search next larger first level\r\n    let flMap = root.flMap & (~0 << (fl + 1));\r\n    if (!flMap) {\r\n      head = null;\r\n    } else {\r\n      fl = ctz<usize>(flMap);\r\n      slMap = GETSL(root, fl);\r\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\r\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n    }\r\n  } else {\r\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n  }\r\n  return head;\r\n}\r\n\r\n/** Prepares the specified block before (re-)use, possibly splitting it. */\r\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\r\n  // size was already asserted by caller\r\n\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\r\n\r\n  // split if the block can hold another MINSIZE block incl. overhead\r\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\r\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\r\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\r\n\r\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\r\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\r\n    insertBlock(root, spare); // also sets 'back'\r\n\r\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\r\n  } else {\r\n    block.mmInfo = blockInfo & ~FREE;\r\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\r\n  }\r\n}\r\n\r\n/** Adds more memory to the pool. */\r\nfunction addMemory(root: Root, start: usize, end: usize): bool {\r\n  if (DEBUG) {\r\n    assert(\r\n      start <= end &&       // must be valid\r\n      !(start & AL_MASK) && // must be aligned\r\n      !(end & AL_MASK)      // must be aligned\r\n    );\r\n  }\r\n\r\n  var tail = GETTAIL(root);\r\n  var tailInfo: usize = 0;\r\n  if (tail) { // more memory\r\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\r\n\r\n    // merge with current tail if adjacent\r\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\r\n      start -= BLOCK_OVERHEAD;\r\n      tailInfo = tail.mmInfo;\r\n    } else {\r\n      // We don't do this, but a user might `memory.grow` manually\r\n      // leading to non-adjacent pages managed by TLSF.\r\n    }\r\n\r\n  } else if (DEBUG) { // first memory\r\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\r\n  }\r\n\r\n  // check if size is large enough for a free block and the tail block\r\n  var size = end - start;\r\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\r\n    return false;\r\n  }\r\n\r\n  // left size is total minus its own and the zero-length tail's header\r\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\r\n  var left = changetype<Block>(start);\r\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\r\n  left.prev = null;\r\n  left.next = null;\r\n\r\n  // tail is a zero-length used block\r\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\r\n  tail.mmInfo = 0 | LEFTFREE;\r\n  SETTAIL(root, tail);\r\n\r\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\r\n\r\n  return true;\r\n}\r\n\r\n/** Grows memory to fit at least another block of the specified size. */\r\nfunction growMemory(root: Root, size: usize): void {\r\n  // Here, both rounding performed in searchBlock ...\r\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\r\n  if (size < halfMaxSize) { // don't round last fl\r\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\r\n    size += (1 << (invRound - clz<usize>(size))) - 1;\r\n  }\r\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\r\n  // to merge with the tail block, that's one time, otherwise it's two times.\r\n  var pagesBefore = memory.size();\r\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\r\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n  if (memory.grow(pagesWanted) < 0) {\r\n    if (memory.grow(pagesNeeded) < 0) unreachable();\r\n  }\r\n  var pagesAfter = memory.size();\r\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n}\r\n\r\n/** Prepares and checks an allocation size. */\r\nfunction prepareSize(size: usize): usize {\r\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\r\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\r\n}\r\n\r\n/** Initilizes the root structure. */\r\nexport function initializeRoot(): void {\r\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n  var root = changetype<Root>(rootOffset);\r\n  root.flMap = 0;\r\n  SETTAIL(root, changetype<Block>(0));\r\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n    SETSL(root, fl, 0);\r\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n      SETHEAD(root, fl, sl, null);\r\n    }\r\n  }\r\n  addMemory(root, (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\r\n  ROOT = root;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar collectLock: bool = false;\r\n\r\n/** Allocates a block of the specified size. */\r\nexport function allocateBlock(root: Root, size: usize): Block {\r\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\r\n  var payloadSize = prepareSize(size);\r\n  var block = searchBlock(root, payloadSize);\r\n  if (!block) {\r\n    if (gc.auto) {\r\n      if (DEBUG) collectLock = true;\r\n      __collect();\r\n      if (DEBUG) collectLock = false;\r\n      block = searchBlock(root, payloadSize);\r\n      if (!block) {\r\n        growMemory(root, payloadSize);\r\n        block = <Block>searchBlock(root, payloadSize);\r\n        if (DEBUG) assert(block); // must be found now\r\n      }\r\n    } else {\r\n      growMemory(root, payloadSize);\r\n      block = <Block>searchBlock(root, payloadSize);\r\n      if (DEBUG) assert(block); // must be found now\r\n    }\r\n  }\r\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\r\n  block.gcInfo = 0; // RC=0\r\n  // block.rtId = 0; // set by the caller (__alloc)\r\n  block.rtSize = size;\r\n  removeBlock(root, <Block>block);\r\n  prepareBlock(root, <Block>block, payloadSize);\r\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\r\n  return <Block>block;\r\n}\r\n\r\n/** Reallocates a block to the specified size. */\r\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) {\r\n    assert(\r\n      !(blockInfo & FREE) &&           // must be used\r\n      !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\r\n    );\r\n  }\r\n\r\n  // possibly split and update runtime size if it still fits\r\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\r\n    prepareBlock(root, block, payloadSize);\r\n    block.rtSize = size;\r\n    return block;\r\n  }\r\n\r\n  // merge with right free block if merger is large enough\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n  if (rightInfo & FREE) {\r\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (mergeSize >= payloadSize) {\r\n      removeBlock(root, right);\r\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\r\n      // is immediately split though. does this trigger any assertions / issues?\r\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\r\n      block.rtSize = size;\r\n      prepareBlock(root, block, payloadSize);\r\n      return block;\r\n    }\r\n  }\r\n\r\n  // otherwise move the block\r\n  var newBlock = allocateBlock(root, size);\r\n  newBlock.rtId = block.rtId;\r\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n  return newBlock;\r\n}\r\n\r\n/** Frees a block. */\r\nexport function freeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  assert(!(blockInfo & FREE)); // must be used (user might call through to this)\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __alloc(size: usize, id: u32): usize {\r\n  var root = ROOT;\r\n  if (!root) {\r\n    initializeRoot();\r\n    root = ROOT;\r\n  }\r\n  var block = allocateBlock(root, size);\r\n  block.rtId = id;\r\n  return changetype<usize>(block) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __realloc(ref: usize, size: usize): usize {\r\n  if (DEBUG) assert(ROOT); // must be initialized\r\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\r\n  return changetype<usize>(reallocateBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD), size)) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __free(ref: usize): void {\r\n  if (DEBUG) assert(ROOT); // must be initialized\r\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\r\n  freeBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\n/** Garbage collector interface. */\r\nexport namespace gc {\r\n\r\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\r\n  export var auto: bool = true;\r\n\r\n  /** Performs a full garbage collection cycle. */\r\n  export function collect(): void {\r\n    __collect();\r\n  }\r\n}\r\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\r\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\r\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare const __rtti_base: usize;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_globals(cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_members(ref: usize, cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __typeinfo(id: u32): TypeinfoFlags {\r\n  var ptr = __rtti_base;\r\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\r\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\r\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\r\n  var ptr = __rtti_base;\r\n  if (id <= load<u32>(ptr)) {\r\n    do if (id == superId) return true;\r\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\r\n  }\r\n  return false;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\r\n  var array = __alloc(offsetof<i32[]>(), id);\r\n  var bufferSize = <usize>length << alignLog2;\r\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\r\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"buffer\"));\r\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\r\n  store<u32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\r\n  store<i32>(changetype<usize>(array), length, offsetof<i32[]>(\"length_\"));\r\n  if (data) memory.copy(buffer, data, bufferSize);\r\n  return array;\r\n}\r\n\r\n// These are provided by the respective implementation, included as another entry file by asc:\r\n\r\n// @builtin @unsafe\r\n// export declare function __alloc(size: usize, id: u32): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __realloc(ref: usize, size: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __free(ref: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __retain(ref: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __release(ref: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __collect(): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __visit(ref: usize, cookie: u32): void;\r\n","// Common error messages for use accross the standard library. Keeping error messages compact\r\n// and reusing them where possible ensures minimal static data in binaries.\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_EMPTYARRAY: string = \"Array is empty\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\r\n","import { memcmp, memmove, memset } from \"./util/memory\";\r\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\r\n\r\n/** Memory manager interface. */\r\nexport namespace memory {\r\n\r\n  /** Gets the size of the memory in pages. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function size(): i32;\r\n\r\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export declare function grow(pages: i32): i32;\r\n\r\n  /** Fills a section in memory with the specified byte value. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function fill(dst: usize, c: u8, n: usize): void {\r\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Copies a section of memory to another. Has move semantics. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function copy(dst: usize, src: usize, n: usize): void {\r\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Initializes a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Drops a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function drop(segmentIndex: u32): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Repeats a section of memory at a specific address. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\r\n    var index: usize = 0;\r\n    var total = srcLength * count;\r\n    while (index < total) {\r\n      memory.copy(dst + index, src, srcLength);\r\n      index += srcLength;\r\n    }\r\n  }\r\n\r\n  /** Compares a section of memory to another. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\r\n    return memcmp(vl, vr, n);\r\n  }\r\n}\r\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    let w: u32, x: u32;\r\n\r\n    // copy 1 byte each until src is aligned to 4 bytes\r\n    while (n && (src & 3)) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      n--;\r\n    }\r\n\r\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n    if ((dest & 3) == 0) {\r\n      while (n >= 16) {\r\n        store<u32>(dest     , load<u32>(src     ));\r\n        store<u32>(dest +  4, load<u32>(src +  4));\r\n        store<u32>(dest +  8, load<u32>(src +  8));\r\n        store<u32>(dest + 12, load<u32>(src + 12));\r\n        src += 16; dest += 16; n -= 16;\r\n      }\r\n      if (n & 8) {\r\n        store<u32>(dest    , load<u32>(src    ));\r\n        store<u32>(dest + 4, load<u32>(src + 4));\r\n        dest += 8; src += 8;\r\n      }\r\n      if (n & 4) {\r\n        store<u32>(dest, load<u32>(src));\r\n        dest += 4; src += 4;\r\n      }\r\n      if (n & 2) { // drop to 2 bytes each\r\n        store<u16>(dest, load<u16>(src));\r\n        dest += 2; src += 2;\r\n      }\r\n      if (n & 1) { // drop to 1 byte\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      return;\r\n    }\r\n\r\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n    if (n >= 32) {\r\n      switch (dest & 3) {\r\n        // known to be != 0\r\n        case 1: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 3;\r\n          while (n >= 17) {\r\n            x = load<u32>(src + 1);\r\n            store<u32>(dest, w >> 24 | x << 8);\r\n            w = load<u32>(src + 5);\r\n            store<u32>(dest + 4, x >> 24 | w << 8);\r\n            x = load<u32>(src + 9);\r\n            store<u32>(dest + 8, w >> 24 | x << 8);\r\n            w = load<u32>(src + 13);\r\n            store<u32>(dest + 12, x >> 24 | w << 8);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n        case 2: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 2;\r\n          while (n >= 18) {\r\n            x = load<u32>(src + 2);\r\n            store<u32>(dest, w >> 16 | x << 16);\r\n            w = load<u32>(src + 6);\r\n            store<u32>(dest + 4, x >> 16 | w << 16);\r\n            x = load<u32>(src + 10);\r\n            store<u32>(dest + 8, w >> 16 | x << 16);\r\n            w = load<u32>(src + 14);\r\n            store<u32>(dest + 12, x >> 16 | w << 16);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n        case 3: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 1;\r\n          while (n >= 19) {\r\n            x = load<u32>(src + 3);\r\n            store<u32>(dest, w >> 8 | x << 24);\r\n            w = load<u32>(src + 7);\r\n            store<u32>(dest + 4, x >> 8 | w << 24);\r\n            x = load<u32>(src + 11);\r\n            store<u32>(dest + 8, w >> 8 | x << 24);\r\n            w = load<u32>(src + 15);\r\n            store<u32>(dest + 12, x >> 8 | w << 24);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // copy remaining bytes one by one\r\n    if (n & 16) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 8) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 4) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 2) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 1) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (src + n <= dest || dest + n <= src) {\r\n      memcpy(dest, src, n);\r\n      return;\r\n    }\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, c);\r\n      --n;\r\n    }\r\n  } else {\r\n    // fill head and tail with minimal branching\r\n    if (!n) return;\r\n    store<u8>(dest, c);\r\n    store<u8>(dest + n - 1, c);\r\n    if (n <= 2) return;\r\n\r\n    store<u8>(dest + 1, c);\r\n    store<u8>(dest + 2, c);\r\n    store<u8>(dest + n - 2, c);\r\n    store<u8>(dest + n - 3, c);\r\n    if (n <= 6) return;\r\n    store<u8>(dest + 3, c);\r\n    store<u8>(dest + n - 4, c);\r\n    if (n <= 8) return;\r\n\r\n    // advance pointer to align it at 4-byte boundary\r\n    let k: usize = -dest & 3;\r\n    dest += k;\r\n    n -= k;\r\n    n &= -4;\r\n\r\n    let c32: u32 = <u32>-1 / 255 * c;\r\n\r\n    // fill head/tail up to 28 bytes each in preparation\r\n    store<u32>(dest, c32);\r\n    store<u32>(dest + n - 4, c32);\r\n    if (n <= 8) return;\r\n    store<u32>(dest + 4, c32);\r\n    store<u32>(dest + 8, c32);\r\n    store<u32>(dest + n - 12, c32);\r\n    store<u32>(dest + n - 8, c32);\r\n    if (n <= 24) return;\r\n    store<u32>(dest + 12, c32);\r\n    store<u32>(dest + 16, c32);\r\n    store<u32>(dest + 20, c32);\r\n    store<u32>(dest + 24, c32);\r\n    store<u32>(dest + n - 28, c32);\r\n    store<u32>(dest + n - 24, c32);\r\n    store<u32>(dest + n - 20, c32);\r\n    store<u32>(dest + n - 16, c32);\r\n\r\n    // align to a multiple of 8\r\n    k = 24 + (dest & 4);\r\n    dest += k;\r\n    n -= k;\r\n\r\n    // copy 32 bytes each\r\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n    while (n >= 32) {\r\n      store<u64>(dest, c64);\r\n      store<u64>(dest + 8, c64);\r\n      store<u64>(dest + 16, c64);\r\n      store<u64>(dest + 24, c64);\r\n      n -= 32;\r\n      dest += 32;\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\r\n  if (vl == vr) return 0;\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if ((vl & 7) == (vr & 7)) {\r\n      while (vl & 7) {\r\n        if (!n) return 0;\r\n        let a = <i32>load<u8>(vl);\r\n        let b = <i32>load<u8>(vr);\r\n        if (a != b) return a - b;\r\n        n--; vl++; vr++;\r\n      }\r\n      while (n >= 8) {\r\n        if (load<u64>(vl) != load<u64>(vr)) break;\r\n        vl += 8;\r\n        vr += 8;\r\n        n  -= 8;\r\n      }\r\n    }\r\n  }\r\n  while (n--) {\r\n    let a = <i32>load<u8>(vl);\r\n    let b = <i32>load<u8>(vr);\r\n    if (a != b) return a - b;\r\n    vl++; vr++;\r\n  }\r\n  return 0;\r\n}\r\n","// The entry file of your WebAssembly module.\n\nexport function add(a: i32, b: i32): i32 {\n  return a + b;\n}\n\n\nexport function run(w: i32, h: i32): i32 {\n  return 1;\n}"]}